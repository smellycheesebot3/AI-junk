<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js WASD Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>

    <!-- Three.js (non‑module version, always works) -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
</head>
<body>

<script>
// ===================== ERROR DISPLAY =====================
window.onerror = function (msg, url, line, col, error) {
    document.body.innerHTML =
        "<div style='padding:20px;font-size:20px;color:white;background:black;'>" +
        "<b>JavaScript Error:</b><br>" +
        msg + "<br><br>" +
        "<b>Line:</b> " + line + "<br>" +
        "<b>Column:</b> " + col + "<br>" +
        "<b>URL:</b> " + url + "<br><br>" +
        "<b>Details:</b><br>" +
        error +
        "</div>";
};

// ===================== SCENE =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// ===================== CAMERA =====================
const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
);
camera.position.set(0, 20, 50);

// ===================== RENDERER =====================
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===================== FLOOR =====================
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshBasicMaterial({ color: 0x228B22 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);
    
    // ===================== STREETS =====================
// Pompeii-style grey clay/basalt roads
const streetMaterial = new THREE.MeshBasicMaterial({ color: 0x6e6e6e });

// Main street
const street1 = new THREE.Mesh(
    new THREE.PlaneGeometry(300, 20),
    streetMaterial
);
street1.rotation.x = -Math.PI / 2;
street1.position.set(0, 0.1, 0);
scene.add(street1);

// Cross street
const street2 = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 300),
    streetMaterial
);
street2.rotation.x = -Math.PI / 2;
street2.position.set(0, 0.1, 0);
scene.add(street2);

// ===================== BROKEN / AGED BUILDINGS =====================
function createBrokenBuilding(x, z, w, h, d) {
    // Base building
    const baseColor = new THREE.Color(0xb5651d);
    baseColor.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2); // slight color variation

    const building = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshBasicMaterial({ color: baseColor })
    );
    building.position.set(x, h / 2, z);

    // Slight tilt (earthquake damage)
    building.rotation.y = (Math.random() - 0.5) * 0.1;
    building.rotation.x = (Math.random() - 0.5) * 0.05;

    scene.add(building);

    // Add broken top section
    const brokenHeight = h * (0.2 + Math.random() * 0.3);
    const rubble = new THREE.Mesh(
        new THREE.BoxGeometry(w * 0.9, brokenHeight, d * 0.9),
        new THREE.MeshBasicMaterial({ color: 0x8a4b2a })
    );
    rubble.position.set(x, h - brokenHeight / 2, z);
    rubble.rotation.y = (Math.random() - 0.5) * 0.3;

    scene.add(rubble);

    // Add cracks (thin black planes)
    for (let i = 0; i < 3; i++) {
        const crack = new THREE.Mesh(
            new THREE.PlaneGeometry(w * 0.8, 0.2),
            new THREE.MeshBasicMaterial({ color: 0x111111 })
        );
        crack.position.set(
            x + (Math.random() - 0.5) * w * 0.6,
            (Math.random() * h),
            z + d / 2 + 0.01
        );
        crack.rotation.y = 0;
        scene.add(crack);
    }
}

// Row of buildings along the main street
createBuilding(-60, -30, 30, 20, 30);
createBuilding(-20, -30, 20, 15, 20);
createBuilding(20, -30, 25, 18, 25);
createBuilding(60, -30, 35, 22, 30);

// Opposite side
createBuilding(-60, 30, 25, 18, 25);
createBuilding(-20, 30, 20, 12, 20);
createBuilding(20, 30, 30, 20, 30);
createBuilding(60, 30, 22, 16, 22);

// Buildings along the cross street
createBuilding(-30, -60, 20, 14, 20);
createBuilding(30, -60, 25, 18, 25);
createBuilding(-30, 60, 22, 16, 22);
createBuilding(30, 60, 28, 20, 28);
    
    // ===================== BUILDING LAYOUT =====================

// Main street rows
for (let i = -120; i <= 120; i += 40) {
    createBrokenBuilding(i, -30, 25 + Math.random()*10, 15 + Math.random()*10, 25);
    createBrokenBuilding(i,  30, 25 + Math.random()*10, 15 + Math.random()*10, 25);
}

// Cross street rows
for (let i = -120; i <= 120; i += 40) {
    createBrokenBuilding(-30, i, 25, 15 + Math.random()*10, 25);
    createBrokenBuilding( 30, i, 25, 15 + Math.random()*10, 25);
}

// Extra inner‑city buildings (fills the blocks)
for (let x = -100; x <= 100; x += 50) {
    for (let z = -100; z <= 100; z += 50) {
        if (Math.abs(x) > 40 || Math.abs(z) > 40) {
            createBrokenBuilding(x, z, 20 + Math.random()*15, 12 + Math.random()*15, 20 + Math.random()*15);
        }
    }
}

// ===================== WASD KEYS =====================
const keys = { w: false, a: false, s: false, d: false };

document.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = true;
});

document.addEventListener("keyup", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = false;
});

// ===================== MOUSE LOOK =====================
let isMouseDown = false;
let prevX = 0;
let prevY = 0;

document.addEventListener("mousedown", (e) => {
    isMouseDown = true;
    prevX = e.clientX;
    prevY = e.clientY;
});

document.addEventListener("mouseup", () => {
    isMouseDown = false;
});

document.addEventListener("mousemove", (e) => {
    if (!isMouseDown) return;

    const dx = e.clientX - prevX;
    const dy = e.clientY - prevY;

    prevX = e.clientX;
    prevY = e.clientY;

    const sensitivity = 0.002;

    // Horizontal rotation
    camera.rotation.y -= dx * sensitivity;

    // Vertical rotation
    camera.rotation.x -= dy * sensitivity;

    // Limit vertical look
    const limit = Math.PI / 2 - 0.1;
    camera.rotation.x = Math.max(-limit, Math.min(limit, camera.rotation.x));
});

// ===================== MOVEMENT FUNCTION =====================
function updateMovement() {
    const speed = 1.0;

    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);

    const right = new THREE.Vector3();
    right.crossVectors(camera.up, forward).normalize();

    if (keys.w) camera.position.add(forward.multiplyScalar(speed));
    if (keys.s) camera.position.add(forward.multiplyScalar(-speed));
    if (keys.a) camera.position.add(right.multiplyScalar(speed));
    if (keys.d) camera.position.add(right.multiplyScalar(-speed));
}

// ===================== ANIMATION LOOP =====================
function animate() {
    requestAnimationFrame(animate);
    updateMovement();
    renderer.render(scene, camera);
}
animate();
</script>
