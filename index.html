<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Kart Racer - Improved</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #hud {
    position: absolute; top: 10px; left: 10px;
    color: white; font-family: system-ui, sans-serif; font-size: 14px;
    background: rgba(0,0,0,0.4); padding: 8px 12px; border-radius: 6px;
  }
  #hud b { color: #ffd34e; }
</style>
</head>
<body>
<div id="hud">
  <div><b>Controls:</b> W/S = accelerate/brake, A/D = steer, Space = handbrake, R = reset</div>
  <div id="lapInfo">Lap: 1 / 3 | Time: 0.0s | Best: --</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

<script>
// --------------------------------------------------
// Scene setup
// --------------------------------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --------------------------------------------------
// Lighting
// --------------------------------------------------
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(60, 100, -40);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

scene.add(new THREE.AmbientLight(0xffffff, 0.45));

// --------------------------------------------------
// Ground
// --------------------------------------------------
const groundGeo = new THREE.PlaneGeometry(2000, 2000);
const groundMat = new THREE.MeshLambertMaterial({ color: 0x2a8b3b });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// --------------------------------------------------
// Figureâ€‘8 track (with reusable curve for "magnet" + lap)
// --------------------------------------------------
let trackCurve;
let trackLength = 0;
function createFigure8Track() {
  const loop1 = new THREE.EllipseCurve(0, 25, 35, 18, 0, Math.PI * 2, false);
  const loop2 = new THREE.EllipseCurve(0, -25, 35, 18, 0, Math.PI * 2, false);

  const points1 = loop1.getSpacedPoints(80).map(p => new THREE.Vector3(p.x, 0, p.y));
  const points2 = loop2.getSpacedPoints(80).map(p => new THREE.Vector3(p.x, 0, p.y));

  const allPoints = [...points1, ...points2];
  trackCurve = new THREE.CatmullRomCurve3(allPoints, true);

  const segments = 400;
  const tmp = trackCurve.getSpacedPoints(segments);
  trackLength = 0;
  for (let i = 1; i < tmp.length; i++) {
    trackLength += tmp[i].distanceTo(tmp[i - 1]);
  }

  const shape = new THREE.Shape();
  const w = 5;
  shape.moveTo(-w, -1);
  shape.lineTo(w, -1);
  shape.lineTo(w, 1);
  shape.lineTo(-w, 1);

  const extrude = new THREE.ExtrudeGeometry(shape, {
    steps: 400,
    bevelEnabled: false,
    extrudePath: trackCurve
  });

  const mat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const mesh = new THREE.Mesh(extrude, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;

  // simple border walls
  const wallGeo = new THREE.BoxGeometry(1, 1, 8);
  const wallMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
  const walls = new THREE.Group();
  for (let i = 0; i < 120; i++) {
    const t = i / 120;
    const p = trackCurve.getPointAt(t);
    const n = trackCurve.getTangentAt(t);
    const left = new THREE.Vector3(-n.z, 0, n.x).normalize();
    const right = left.clone().multiplyScalar(-1);

    const w1 = new THREE.Mesh(wallGeo, wallMat);
    w1.position.copy(p).add(left.multiplyScalar(6));
    w1.position.y = 0.5;
    w1.castShadow = true;
    w1.receiveShadow = true;
    walls.add(w1);

    const w2 = new THREE.Mesh(wallGeo, wallMat);
    w2.position.copy(p).add(right.multiplyScalar(6));
    w2.position.y = 0.5;
    w2.castShadow = true;
    w2.receiveShadow = true;
    walls.add(w2);
  }

  const trackGroup = new THREE.Group();
  trackGroup.add(mesh);
  trackGroup.add(walls);
  return trackGroup;
}

const trackGroup = createFigure8Track();
scene.add(trackGroup);

// --------------------------------------------------
// Kart
// --------------------------------------------------
const kart = new THREE.Group();

// Body
const bodyGeo = new THREE.BoxGeometry(1.6, 0.6, 2.2);
const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff3333 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.castShadow = true;
kart.add(body);

// Seat
const seatGeo = new THREE.BoxGeometry(0.8, 0.5, 0.8);
const seatMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
const seat = new THREE.Mesh(seatGeo, seatMat);
seat.position.set(0, 0.4, -0.2);
seat.castShadow = true;
kart.add(seat);

// Wheels
function wheel(x, z) {
  const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.4, 16);
  const mat = new THREE.MeshLambertMaterial({ color: 0x111111 });
  const w = new THREE.Mesh(geo, mat);
  w.rotation.z = Math.PI / 2;
  w.position.set(x, -0.25, z);
  w.castShadow = true;
  return w;
}
kart.add(wheel(0.9, 0.9));
kart.add(wheel(-0.9, 0.9));
kart.add(wheel(0.9, -0.9));
kart.add(wheel(-0.9, -0.9));

kart.position.set(0, 0.5, 27);
scene.add(kart);

// --------------------------------------------------
// Control state
// --------------------------------------------------
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

let speed = 0;
let angle = Math.PI; // facing "down" the Z axis
let trackParam = 0;  // 0..1 along figure-8
let lastParam = 0;

// Lap system
const lapsToWin = 3;
let currentLap = 1;
let lapStartTime = performance.now();
let bestLapTime = null;
let hasCrossedHalf = false; // to stop cheating by wobbling around start/finish

const hudLap = document.getElementById("lapInfo");

// --------------------------------------------------
// Utility: find nearest point on curve for kart
// --------------------------------------------------
function getNearestTrackParam(pos, searchSamples = 80, searchRadius = 0.02) {
  let bestT = trackParam;
  let bestDist = Infinity;
  const start = (trackParam - searchRadius + 1) % 1;
  const end = (trackParam + searchRadius + 1) % 1;

  for (let i = 0; i <= searchSamples; i++) {
    const t = (start + (end - start) * (i / searchSamples) + 1) % 1;
    const p = trackCurve.getPointAt(t);
    const d = p.distanceTo(pos);
    if (d < bestDist) {
      bestDist = d;
      bestT = t;
    }
  }
  return bestT;
}

function getDistanceAlongTrack(fromT, toT) {
  let d = (toT - fromT) * trackLength;
  if (d < -trackLength / 2) d += trackLength;
  if (d > trackLength / 2) d -= trackLength;
  return d;
}

// --------------------------------------------------
// Camera: smooth chase
// --------------------------------------------------
const camTarget = new THREE.Vector3();
const camPos = new THREE.Vector3();
const camOffsetLocal = new THREE.Vector3(0, 4, -8);

// --------------------------------------------------
// Reset kart
// --------------------------------------------------
function resetKart() {
  trackParam = 0;
  const p = trackCurve.getPointAt(trackParam);
  const tangent = trackCurve.getTangentAt(trackParam);
  angle = Math.atan2(tangent.x, tangent.z);
  kart.position.copy(p);
  kart.position.y = 0.5;
  speed = 0;
}

resetKart();

// --------------------------------------------------
// Main loop
// --------------------------------------------------
let lastTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  // Controls
  const accel = 3.5;
  const maxSpeed = 18;
  const turnStrength = 2.2;
  const handbrakeFactor = keys["Space"] ? 0.7 : 1;

  if (keys["KeyW"]) speed += accel * dt;
  if (keys["KeyS"]) speed -= accel * dt * 0.8;

  if (keys["Space"]) speed *= 0.95;
  else speed *= 0.985;

  if (speed > maxSpeed) speed = maxSpeed;
  if (speed < -maxSpeed * 0.4) speed = -maxSpeed * 0.4;

  // Steering: scaled by speed and blended to avoid instant snaps
  const steerInput = (keys["KeyA"] ? 1 : 0) - (keys["KeyD"] ? 1 : 0);
  const steer = steerInput * turnStrength * (speed / maxSpeed) * handbrakeFactor;
  angle += steer * dt;

  // Move kart forward in its local direction
  kart.position.x += Math.sin(angle) * speed * dt;
  kart.position.z += Math.cos(angle) * speed * dt;

  // Track magnet: pull kart gently back towards nearest point on track
  const nearestT = getNearestTrackParam(kart.position);
  const nearestPoint = trackCurve.getPointAt(nearestT);
  const toTrack = nearestPoint.clone().sub(kart.position);
  const distFromTrack = toTrack.length();

  if (distFromTrack > 0.4) {
    toTrack.normalize();
    const pull = Math.min(distFromTrack, 2.5);
    kart.position.addScaledVector(toTrack, pull * dt * 3.5);
  }

  // Align forward direction slowly with track tangent
  const tangent = trackCurve.getTangentAt(nearestT);
  const targetAngle = Math.atan2(tangent.x, tangent.z);
  let angleDiff = targetAngle - angle;
  angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
  angle += angleDiff * dt * 1.8;

  kart.rotation.y = angle;
  kart.position.y = 0.5;

  lastParam = trackParam;
  trackParam = nearestT;

  // Lap detection
  const distMoved = getDistanceAlongTrack(lastParam, trackParam);
  const middlePos = trackCurve.getPointAt(0.5);
  const passedMiddle = middlePos.distanceTo(kart.position) < 6;

  if (passedMiddle) {
    hasCrossedHalf = true;
  }

  const startPos = trackCurve.getPointAt(0);
  const nearStart = startPos.distanceTo(kart.position) < 6;
  if (nearStart && hasCrossedHalf && distMoved < 0) {
    const lapTime = (now - lapStartTime) / 1000;
    if (!bestLapTime || lapTime < bestLapTime) {
      bestLapTime = lapTime;
    }
    lapStartTime = now;
    hasCrossedHalf = false;
    currentLap++;
    if (currentLap > lapsToWin) {
      currentLap = lapsToWin;
    }
  }

  const currentLapTime = (now - lapStartTime) / 1000;
  hudLap.textContent =
    `Lap: ${currentLap} / ${lapsToWin} | Time: ${currentLapTime.toFixed(1)}s` +
    ` | Best: ${bestLapTime ? bestLapTime.toFixed(1) + "s" : "--"}`;

  // Reset
  if (keys["KeyR"]) resetKart();

  // Camera
  const forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
  const camOffset = camOffsetLocal.clone();
  camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), angle);
  const desiredCamPos = kart.position.clone().add(camOffset);
  camPos.lerp(desiredCamPos, 0.1);
  camTarget.lerp(kart.position.clone().add(new THREE.Vector3(0, 1.0, 0)), 0.15);

  camera.position.copy(camPos);
  camera.lookAt(camTarget);

  renderer.render(scene, camera);
}

animate(performance.now());

// --------------------------------------------------
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
