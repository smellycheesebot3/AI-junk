<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js WASD Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>

    <!-- Three.js (non‑module version, always works) -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
</head>
<body>

<script>
// ===================== ERROR DISPLAY =====================
window.onerror = function (msg, url, line, col, error) {
    document.body.innerHTML =
        "<div style='padding:20px;font-size:20px;color:white;background:black;'>" +
        "<b>JavaScript Error:</b><br>" +
        msg + "<br><br>" +
        "<b>Line:</b> " + line + "<br>" +
        "<b>Column:</b> " + col + "<br>" +
        "<b>URL:</b> " + url + "<br><br>" +
        "<b>Details:</b><br>" +
        error +
        "</div>";
};

// ===================== SCENE =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// ===================== CAMERA =====================
const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
);
camera.position.set(0, 20, 50);

// ===================== RENDERER =====================
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===================== FLOOR =====================
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(800, 800),
    new THREE.MeshStandardMaterial({ color: 0xB66A50 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);
    
// ===================== STREETS =====================
// Pompeii-style grey clay/basalt roads
const streetMaterial = new THREE.MeshStandardMaterial({ color: 0x6e6e6e });

// Main street
const street1 = new THREE.Mesh(
    new THREE.PlaneGeometry(630, 25),
    streetMaterial
);
street1.rotation.x = -Math.PI / 2;
street1.position.set(0, 0.1, 0);
scene.add(street1);

// Cross street
const street2 = new THREE.Mesh(
    new THREE.PlaneGeometry(25, 630),
    streetMaterial
);
street2.rotation.x = -Math.PI / 2;
street2.position.set(0, 0.1, 0);
scene.add(street2);

// ===================== STREET AVOIDANCE =====================
function isOnStreet(x, z) {
    const streetWidth = 20;

    if (Math.abs(z) < streetWidth / 2) return true;
    if (Math.abs(x) < streetWidth / 2) return true;

    return false;
}

// ===================== TEXTURES =====================
const texLoader = new THREE.TextureLoader();

// Public‑domain textures
const wallTex = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/plaster/plaster_01_diff_1k.jpg");
const wallNorm = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/plaster/plaster_01_nor_gl_1k.png");
const wallRough = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/plaster/plaster_01_rough_1k.jpg");

const roofTex = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/roof_tiles/roof_tiles_02_diff_1k.jpg");
const roofNorm = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/roof_tiles/roof_tiles_02_nor_gl_1k.png");

const stoneTex = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/stone/stone_wall_02_diff_1k.jpg");
const stoneNorm = texLoader.load("https://cdn.jsdelivr.net/gh/Poly-Haven/Textures/stone/stone_wall_02_nor_gl_1k.png");

// ===================== REALISTIC POMPEII BUILDINGS =====================
function createBrokenBuilding(x, z, w, h, d) {
    if (isOnStreet(x, z)) return;

    // Pompeii‑style variation
    w *= 0.6 + Math.random() * 0.4;
    h *= 0.5 + Math.random() * 0.5;
    d *= 0.6 + Math.random() * 0.4;

    // Wall material
    const wallMat = new THREE.MeshStandardMaterial({
        map: wallTex,
        normalMap: wallNorm,
        roughnessMap: wallRough,
        roughness: 0.95
    });

    // Main building block
    const building = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        wallMat
    );
    building.position.set(x, h / 2, z);

    // Earthquake tilt
    building.rotation.y = (Math.random() - 0.5) * 0.2;
    building.rotation.x = (Math.random() - 0.5) * 0.05;

    scene.add(building);

    // Stone foundation
    const foundation = new THREE.Mesh(
        new THREE.BoxGeometry(w * 1.05, 0.4, d * 1.05),
        new THREE.MeshStandardMaterial({
            map: stoneTex,
            normalMap: stoneNorm,
            roughness: 1.0
        })
    );
    foundation.position.set(x, 0.2, z);
    scene.add(foundation);

    // Terracotta roof
    const roof = new THREE.Mesh(
        new THREE.BoxGeometry(w * 1.05, 0.25, d * 1.05),
        new THREE.MeshStandardMaterial({
            map: roofTex,
            normalMap: roofNorm,
            roughness: 0.9
        })
    );
    roof.position.set(x, h, z);

    roof.rotation.x = (Math.random() - 0.5) * 0.25;
    roof.rotation.z = (Math.random() - 0.5) * 0.25;

    scene.add(roof);

    // Windows
    const windowMat = new THREE.MeshStandardMaterial({ color: 0x674123 });

    for (let i = 0; i < 2 + Math.random() * 3; i++) {
        const win = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            windowMat
        );
        win.position.set(
            x + (Math.random() - 0.5) * w * 0.6,
            (Math.random() * h * 0.6) + h * 0.2,
            z + d / 2 + 0.01
        );
        building.add(win);
    }

    // Door
    const door = new THREE.Mesh(
        new THREE.PlaneGeometry(1.8, 2.8),
        new THREE.MeshStandardMaterial({ color: 0x8b6c5c })
    );
    door.position.set(x, 1.4, z + d / 2 + 0.02);
    building.add(door);

    // Wall damage
    for (let i = 0; i < 1 + Math.random() * 3; i++) {
        const hole = new THREE.Mesh(
            new THREE.BoxGeometry(
                1 + Math.random() * 2,
                1 + Math.random() * 2,
                0.2
            ),
            new THREE.MeshStandardMaterial({ color: 0x2b1a10 })
        );
        hole.position.set(
            x + (Math.random() - 0.5) * w * 0.7,
            (Math.random() * h * 0.8),
            z + d / 2 + 0.11
        );
        scene.add(hole);
    }

    // Rubble on roof
    const rubble = new THREE.Mesh(
        new THREE.BoxGeometry(
            w * (0.4 + Math.random() * 0.3),
            h * 0.15,
            d * (0.4 + Math.random() * 0.3)
        ),
        new THREE.MeshStandardMaterial({ color: 0x5a3a22 })
    );
    rubble.position.set(x, h - 0.1, z);
    rubble.rotation.y = (Math.random() - 0.5) * 0.4;
    scene.add(rubble);
}

// ===================== LIGHTING (REQUIRED FOR REALISM) =====================
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(200, 300, 150);
scene.add(sun);

const ambient = new THREE.AmbientLight(0xffffff, 0.45);
scene.add(ambient);

// ===================== EXTRA BUILDING RINGS =====================
for (let x = -180; x <= 180; x += 45) {
    for (let z = -180; z <= 180; z += 45) {
        if (!isOnStreet(x, z)) {
            createBrokenBuilding(
                x, z,
                20 + Math.random()*20,
                12 + Math.random()*18,
                20 + Math.random()*20
            );
        }
    }
}

// Outskirts
for (let x = -260; x <= 260; x += 65) {
    for (let z = -260; z <= 260; z += 65) {
        if (!isOnStreet(x, z)) {
            createBrokenBuilding(
                x, z,
                25 + Math.random()*25,
                15 + Math.random()*20,
                25 + Math.random()*25
            );
        }
    }
}

// Random small ruins
for (let i = 0; i < 80; i++) {
    const x = (Math.random() - 0.5) * 600;
    const z = (Math.random() - 0.5) * 600;

    if (!isOnStreet(x, z)) {
        createBrokenBuilding(
            x, z,
            10 + Math.random()*10,
            6 + Math.random()*8,
            10 + Math.random()*10
        );
    }
}

// Main street buildings
for (let i = -120; i <= 120; i += 40) {
    createBrokenBuilding(i, -30, 25 + Math.random()*10, 15 + Math.random()*10, 25);
    createBrokenBuilding(i,  30, 25 + Math.random()*10, 15 + Math.random()*10, 25);
}

// Cross street buildings
for (let i = -120; i <= 120; i += 40) {
    createBrokenBuilding(-30, i, 25, 15 + Math.random()*10, 25);
    createBrokenBuilding( 30, i, 25, 15 + Math.random()*10, 25);
}

// Fill city blocks
for (let x = -100; x <= 100; x += 50) {
    for (let z = -100; z <= 100; z += 50) {
        if (!isOnStreet(x, z)) {
            createBrokenBuilding(
                x, z,
                20 + Math.random()*15,
                12 + Math.random()*15,
                20 + Math.random()*15
            );
        }
    }
}

// ===================== MOUNT VESUVIUS =====================

// Volcano base (large cone)
const vesuviusGeometry = new THREE.ConeGeometry(180, 250, 32);
const vesuviusMaterial = new THREE.MeshStandardMaterial({ color: 0x5a4a3a });
const vesuvius = new THREE.Mesh(vesuviusGeometry, vesuviusMaterial);

// Position it behind the city
vesuvius.position.set(0, 125, -400);
scene.add(vesuvius);

// Crater (smaller inverted cone)
const craterGeometry = new THREE.ConeGeometry(60, 40, 32);
const craterMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2a1a });
const crater = new THREE.Mesh(craterGeometry, craterMaterial);

crater.position.set(0, 250, -400);
crater.rotation.x = Math.PI; // flip upside down
scene.add(crater);

// Ashy top (dark ring)
const ashGeometry = new THREE.CylinderGeometry(70, 80, 10, 32);
const ashMaterial = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
const ash = new THREE.Mesh(ashGeometry, ashMaterial);

ash.position.set(0, 245, -400);
scene.add(ash);

// ===================== WASD KEYS =====================
const keys = { w: false, a: false, s: false, d: false };

document.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = true;
});

document.addEventListener("keyup", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = false;
});

// ===================== MOUSE LOOK =====================
let isMouseDown = false;
let prevX = 0;
let prevY = 0;

document.addEventListener("mousedown", (e) => {
    isMouseDown = true;
    prevX = e.clientX;
    prevY = e.clientY;
});

document.addEventListener("mouseup", () => {
    isMouseDown = false;
});

document.addEventListener("mousemove", (e) => {
    if (!isMouseDown) return;

    const dx = e.clientX - prevX;
    const dy = e.clientY - prevY;

    prevX = e.clientX;
    prevY = e.clientY;

    const sensitivity = 0.002;

    // Horizontal rotation
    camera.rotation.y -= dx * sensitivity;

    // Vertical rotation
    camera.rotation.x -= dy * sensitivity;

    // Limit vertical look
    const limit = Math.PI / 2 - 0.1;
    camera.rotation.x = Math.max(-limit, Math.min(limit, camera.rotation.x));
});

// ===================== MOVEMENT FUNCTION =====================
function updateMovement() {
    const speed = 1.0;

    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);

    const right = new THREE.Vector3();
    right.crossVectors(camera.up, forward).normalize();

    if (keys.w) camera.position.add(forward.multiplyScalar(speed));
    if (keys.s) camera.position.add(forward.multiplyScalar(-speed));
    if (keys.a) camera.position.add(right.multiplyScalar(speed));
    if (keys.d) camera.position.add(right.multiplyScalar(-speed));
}

// ===================== ANIMATION LOOP =====================
function animate() {
    requestAnimationFrame(animate);
    updateMovement();
    renderer.render(scene, camera);
}
animate();
</script>
