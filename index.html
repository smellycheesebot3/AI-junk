<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js WASD Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>

    <!-- Three.js (nonâ€‘module version, always works) -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
</head>
<body>

<script>
// ===================== ERROR DISPLAY =====================
window.onerror = function (msg, url, line, col, error) {
    document.body.innerHTML =
        "<div style='padding:20px;font-size:20px;color:white;background:black;'>" +
        "<b>JavaScript Error:</b><br>" +
        msg + "<br><br>" +
        "<b>Line:</b> " + line + "<br>" +
        "<b>Column:</b> " + col + "<br>" +
        "<b>URL:</b> " + url + "<br><br>" +
        "<b>Details:</b><br>" +
        error +
        "</div>";
};

// ===================== SCENE =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// ===================== CAMERA =====================
const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
);
camera.position.set(0, 20, 50);

// ===================== RENDERER =====================
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===================== FLOOR =====================
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshBasicMaterial({ color: 0x228B22 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);
    
    // ===================== STREETS =====================
// Pompeii-style grey clay/basalt roads
const streetMaterial = new THREE.MeshBasicMaterial({ color: 0x6e6e6e });

// Main street
const street1 = new THREE.Mesh(
    new THREE.PlaneGeometry(300, 20),
    streetMaterial
);
street1.rotation.x = -Math.PI / 2;
street1.position.set(0, 0.1, 0);
scene.add(street1);

// Cross street
const street2 = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 300),
    streetMaterial
);
street2.rotation.x = -Math.PI / 2;
street2.position.set(0, 0.1, 0);
scene.add(street2);

// ===================== BUILDINGS =====================
function createBuilding(x, z, w, h, d) {
    const building = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshBasicMaterial({ color: 0xb5651d }) // clay/brick color
    );
    building.position.set(x, h / 2, z);
    scene.add(building);
}

// Row of buildings along the main street
createBuilding(-60, -30, 30, 20, 30);
createBuilding(-20, -30, 20, 15, 20);
createBuilding(20, -30, 25, 18, 25);
createBuilding(60, -30, 35, 22, 30);

// Opposite side
createBuilding(-60, 30, 25, 18, 25);
createBuilding(-20, 30, 20, 12, 20);
createBuilding(20, 30, 30, 20, 30);
createBuilding(60, 30, 22, 16, 22);

// Buildings along the cross street
createBuilding(-30, -60, 20, 14, 20);
createBuilding(30, -60, 25, 18, 25);
createBuilding(-30, 60, 22, 16, 22);
createBuilding(30, 60, 28, 20, 28);

// ===================== WASD KEYS =====================
const keys = { w: false, a: false, s: false, d: false };

document.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = true;
});

document.addEventListener("keyup", e => {
    const k = e.key.toLowerCase();
    if (keys[k] !== undefined) keys[k] = false;
});

// ===================== MOUSE LOOK =====================
let isMouseDown = false;
let prevX = 0;
let prevY = 0;

document.addEventListener("mousedown", (e) => {
    isMouseDown = true;
    prevX = e.clientX;
    prevY = e.clientY;
});

document.addEventListener("mouseup", () => {
    isMouseDown = false;
});

document.addEventListener("mousemove", (e) => {
    if (!isMouseDown) return;

    const dx = e.clientX - prevX;
    const dy = e.clientY - prevY;

    prevX = e.clientX;
    prevY = e.clientY;

    const sensitivity = 0.002;

    // Horizontal rotation
    camera.rotation.y -= dx * sensitivity;

    // Vertical rotation
    camera.rotation.x -= dy * sensitivity;

    // Limit vertical look
    const limit = Math.PI / 2 - 0.1;
    camera.rotation.x = Math.max(-limit, Math.min(limit, camera.rotation.x));
});

// ===================== MOVEMENT FUNCTION =====================
function updateMovement() {
    const speed = 1.0;

    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);

    const right = new THREE.Vector3();
    right.crossVectors(camera.up, forward).normalize();

    if (keys.w) camera.position.add(forward.multiplyScalar(speed));
    if (keys.s) camera.position.add(forward.multiplyScalar(-speed));
    if (keys.a) camera.position.add(right.multiplyScalar(speed));
    if (keys.d) camera.position.add(right.multiplyScalar(-speed));
}

// ===================== ANIMATION LOOP =====================
function animate() {
    requestAnimationFrame(animate);
    updateMovement();
    renderer.render(scene, camera);
}
animate();
</script>
